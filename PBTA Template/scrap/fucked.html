<script type="text/javascript">

	// Code testing reveals that the generateRowID function does not generate a unique ID 100% of the time when adding many rows at once, so we've got to 

	var uniqueids = {};

	var logs = 0;

	var prefixedLogging = false;

	var log = function(t,c) {
		logs++;
		if ( prefixedLogging ) {
			if ( typeof c === "undefined" ) {
				console.log(`${logs}:`);
			} else {
				console.log(`${logs} - ${c}:`)
			}
		}
		console.log(t);
	};
	
	var generateActuallyUniqueRowID = function() {
		var generated = generateRowID();
		while ( uniqueids[generated] === true ) {
			log("generateActuallyUniqueRowID: " + generated + " is not a unique ID, trying again.");
			generated = generateRowID();
		}
		// log("generateActuallyUniqueRowID: " + generated + " verified as unique, returning.");
		uniqueids[generated] = true;
		return generated;
	};
	
	var gTBK = function(t) {
		var result = getTranslationByKey(t);
		// log(`${t} -> ${result}`,"translation")
		if ( result === false ) {
			log("could not translate: " + t);
			return "UNTRANSLATED ["+t+"]";
		} else {
			if ( result === "" ) { return ""; }
			else { return result; }
		}
	};

	// data

	var xpmax = 5;
	
	// For TSL, all playbooks have identical advancement options, so that's the reduced-case I'll implement here.
	// Advances model will need to be expanded for other playbooks when supporting other PBTA
	
	// English data here, translation will occur internal to functions
	
	var advances = [
		{
			text: "Take another move from your playbook",
		},
		{
			text: "Take another move from your playbook",
		},
		{
			text: "Take a move from any playbook",
		},
		{
			text: "Take a move from any playbook",
		},
		{
			text: "Add 1 to a stat (max stat of 3)",
		},
		{
			text: "Add 1 to a stat (max stat of 3)",
		},
		{
			text: "Switch to a new playbook",
			preamble: "Your first five Advances must be from the top six on the list. After you take your fifth Advance, you can choose to switch to another playbook or live happily ever after. Choose one of these last two options when the emotional conflict at the core of your playbook has been resolved or eclipsed by a new conflict corresponding to a new playbook.",
		},
		{
			text: "Live happily ever after",
		}
	];

	var looks = {
		demeanor: "Demeanor",
		clothes: "Clothes",
		sword: "Sword"
	};
	
	// Do I want to process the internationalization outside of various handlers? I feel like keeping them inside the handlers means it doesn't try until it's needed, and most of the translation only happens during a one-time setup, with a few small exceptions. 

	/*
	for(var [k,v] of Object.entries(looks)) {
		looks[k] = gTBK(v);
	}
	*/

	var stats = {
		daring: "Daring",
		grace: "Grace",
		heart: "Heart",
		wit: "Wit",
		spirit: "Spirit"
	};
	
	var sdesc = {
		daring: "skill at arms, forcefulness",
		grace: "elegance, agility",
		heart: "emotional awareness, expression",
		wit: "cleverness, knowledge",
		spirit: "integrity, metaphysical power"
	};

	var conditions = {
		angry: {
			name: "Angry",
			penalty: -2,
			penalized: "Figure Out a Person",
			clearwhen: "To clear, break something important to you or someone you care about",
			marked: ""
		},
		frightened: {
			name: "Frightened",
			penalty: -2,
			penalized: "Fight",
			clearwhen: "To clear, run away and leave something important behind",
			marked: ""
		},
		guilty: {
			name: "Guilty",
			penalty: -2,
			penalized: "Emotional Support",
			clearwhen: "To clear, sacrifice something important just to hurt yourself for what you did",
			marked: ""
		},
		hopeless: {
			name: "Hopeless",
			penalty: -2,
			penalized: "Defy Disaster",
			clearwhen: "To clear, lose yourself in escapism or pleasure when you should be doing something important",
			marked: ""
		},
		insecure: {
			name: "Insecure",
			penalty: -2,
			penalized: "Entice",
			clearwhen: "To clear, take rash action to confront the object of your jealousy and prove your worth without any plan or advice",
			marked: ""
		}
	};
	
	// Basic moves array, essentially the same as a playbook's, tho with those 'header' and 'subheader' bits. (Subheader bits might get deployed for playbook moves tho!)

	var basicmoves = [
		{
			header: "Basic Moves"
		},
		{
			subheader: "Danger Moves"
		},
		{
			name: "Fight",
			body: "When you seek to incapacitate someone with violence, roll +Daring or +Grace:",
			hit: "Choose 3 and your opponent chooses 1 to apply to you in response",
			mixed: "Choose 2 and your opponent chooses 1",
			mixedbullets: [
				"Flirt with or provoke your opponent and gain a String on them",
				"Through violence or cutting words, inflict a Condition",
				"Create an opportunity for an ally through prowess or distraction",
				"Take an object from your opponent or seize a superior position"
			],
			rolled: "yes"
		},
		{
			name: "Defy Disaster",
			body: "When you push your limits to achieve something extraordinary that’s not covered by another move, or to avert an imminent danger to yourself or someone else, say what you’re willing to sacrifice and pick your approach:",
			bullets: [
				"Might, endurance, or courage. +Daring",
				"Swiftness or elegance. +Grace",
				"Charm or social insight. +Heart",
				"Cleverness or knowledge. +Wit",
				"Willpower or metaphysical skill. +Spirit"
			],
			hit: "Do it with style. At the GM’s discretion, you may also learn new information, discover a new opportunity, or gain a String on someone.",
			mixed: "The GM will offer you a hard choice or success with a sacrifice.",
			rolled: "yes", // default no; if yes, there will be a roll button
		},
		{
			name: "Stagger (Reactive Move)",
			body: "When you suffer a staggering physical or emotional blow, choose an option from the following based on the number of Conditions you have marked.",
			preamble: "4 or 5 Conditions:", // a second paragraph usually introducing a set of options
			bullets: [
				"You’re rendered helpless for the scene",
				"You’re utterly humiliated and news will spread; this could be a consequence of a setback in the confrontation, or might be caused by something you confess in the heat of the moment",
				'Choose 2 from the "0–3 Conditions" options'
			],
			alternative: "0-3 Conditions:", // a second section introducing a second set of options
			altbullets: [
				"You lash out at someone whose regard matters to you: provoke them to do something foolish or harmful and take advantage of a String on them if you have one",
				"You hesitate or stumble and the opposition gains an opportunity",
				"You grin and bear the blow; mark two Conditions"
			],
			rolled: "no", // default no; if yes, there will be a roll button
		},
		{
			subheader: "Heartstring Moves"
		},
		{
			name: "Entice",
			body: "When you appeal to someone’s physical or romantic sensibilities, roll +Heart:",
			hit: "Gain a String on them and they choose 1",
			mixed: "Gain a String on them, unless they decide instead to choose 1",
			mixedbullets: [
				"Get flustered and awkward",
				"Promise something they think you want",
				"Give in to desire"
			],
			rolled: "yes", // default no; if yes, there will be a roll button
			rolldefault: "heart" 
		},
		{
			name: "Figure Out a Person",
			body: "When you try to understand a person, roll +Wit (+3 more if you spend a String on them):",
			hit: "You may ask 2 questions, now or later in the scene",
			mixed: "You may ask 2 questions, but they may ask 1 of you",
			mixedbullets: [
				"What are your feelings towards _____?",
				"What do you hope to get from _____?",
				"How could I get you to _____?",
				"What do you love most?",
				"How would you feel if I _____?"
			],
			rolled: "yes", // default no; if yes, there will be a roll button
			rolldefault: "wit" 
		},
		{
			name: "Emotional Support",
			body: "When you offer someone support in a way that could be meaningful to them, roll +Heart or +Spirit (+3 more if you spend a String on them):",
			hit: "If they open up to you, they choose 1, and you either choose 1 or take a String on them",
			mixed: "If they open up to you, they choose 1",
			mixedbullets: [
				"Clear a Condition",
				"Mark XP",
				"+1 forward",
				"Gain insight from the GM about an obstacle facing one of you"
			],
			alternative: "If they’re Smitten with you, they may choose an additional option.", 
			end: "If you’re Smitten with them and they refuse to open up to you, it stings. You mark a Condition.", // a closing paragraph
			rolled: "yes"
		},
		{
			name: "Finally Kiss, in a Dangerous Situation",
			body: "When people finally kiss after a period of tension, each takes +1 ongoing to get to safety and protect the other for the rest of the scene.",
			preamble: "If more than two people finally kiss in these circumstances, they all get the bonus. Each participant must be enthusiastic about kissing to trigger this move.", // a second paragraph usually introducing a set of options
			rolled: "no"
		},
		{
			name: "Influence With a String",
			body: "At any time, spend a String on someone to do one of the following:",
			bullets: [
				"Offer them an XP to do something (don’t spend the String if they refuse the temptation)",
				"Find out what it will take to get them to do what you want (for an NPC, spending the String means they may simply agree)",
				"Add 1 to your roll against them (after rolling)",
				"Add or subtract 1 from any roll they make (after rolling)"
			],
			end: "Each character may only spend one String to add or subtract from a given roll.", // a closing paragraph
			rolled: "no", // default no; if yes, there will be a roll button
		},
		{
			name: "String Advance",
			body: "If you gain a fourth String on someone, you have a profound insight and learn something about them that even they don’t know; the player tells you what you learn, possibly asking the GM for ideas. It’s up to you whether you share that insight with the character or not. In addition, clear all but one of your Strings on them and gain 2 XP.",
			rolled: "no"
		},
		{
			name: "Smitten",
			body: "When you become Smitten with someone (always your choice), say why, give them a String on you, and answer the question in the Truths of Heart and Blade section of your playbook.",
			rolled: "no", // default no; if yes, there will be a roll button
			rolldefault: "It gains a String on you" 
		},
		{
			subheader: "Special Moves"
		},
		{
			name: "Call on a Toxic Power",
			body: "When you parley with a Toxic Power, ask it your question and roll +Spirit:",
			hit: "It answers the question and grants you +1 forward to act on the information",
			mixed: "It answers the question and the GM chooses 1",
			mixedbullets: [
				"It takes something from you, either knowledge, reputation, or something physical",
				"You mark a Condition",
				"It gains a String on you"
			],
			rolled: "yes", // default no; if yes, there will be a roll button
			rolldefault: "spirit" 
		},
		{
			name: "End of Session",
			body: "Each player marks XP if, during the session:",
			bullets: [
				"Any PC confessed their love",
				"Any PC de-escalated a violent situation",
				"Any PC leapt into danger with daring and panache",
				"Any player used a safety tool such as the palette or Check-In Card"
			],
			rolled: "no"
		}
	];

	var playbooks = {
		"beast": { 
			name: "The Beast",
			look: {
				demeanor: "wild demeanor, hungry demeanor, piercing demeanor",
				clothes: "torn clothes, practical clothes, chitinous clothes, raider's clothes",
				sword: "a cold-wrought sword, a sword of teeth, a found sword"
			},
			startstats: [
				{ daring: 1, grace: 0, heart: 1, wit: -1, spirit: 0 },
				{ daring: 1, grace: 1, heart: -1, wit: 0, spirit: 0 }
			],
			movesinstructions: "(start with the move marked and choose two more)",
			moves: [
				{
					name: "Transform",
					body: "You have a bestial form, which you can assume at will and must assume whenever your Feral hits 4. When you do, tell everyone what the beast in you looks like, increase your Feral to 4 if it’s not there already, and roll +Daring:",
					hit: "Choose 2",
					mixed: "Choose 1",
					rolled: "yes",
					rolldefault: "daring",
					mixedbullets: [
						"You are in harmony with your beast and may clear a Condition",
						"You are magnificent and little escapes your notice; you gain leverage or an opportunity with a monster",
						"Pain is nothing to you; ignore the next time you would Stagger while transformed",
						"You can move in ways no ordinary person could"
					],
					end: "You revert to your usual form when your Feral drops below 4. While transformed, you may mark a Condition to avoid reducing your Feral, as often as you like.",
					pbdefault: "yes"
				},
				{
					name: "Big Dyke Energy",
					body: "When you make it clear to your foes that you’re the biggest threat, then for the rest of the scene, whenever you roll a 10+, you may choose someone present to be impressed or intrigued with you. Once during the scene, when you gain a String on someone, gain an additional String on someone else who considers you an enemy"
				},
				{
					name: "Ferocious",
					body: "When you Fight, you may mark a Condition to choose an additional option, even on a 6-."
				},
				{
					name: "Shameless",
					body: "When you say aloud what you want from an NPC, you may give them a String on you to ask a question about them from the Figure Out move."
				},
				{
					name: "Tenacious Purpose",
					body: "When you commit yourself to a specific goal, you may ask the GM once per scene how you could advance that goal in a way that violates “civilized” norms. Take +1 forward to act on the answer. If you refrain, it counts as an uncomfortable situation that reduces your Feral by 1 and you must mark a Condition."
				},
				{
					name: "Tracker",
					body: "When you investigate a person’s living space, camp, or trail, or an object important to them, you can roll +Heart instead of +Wit to Figure Them Out, and may do so even when they’re not present. You can also ask the question, “Where did they go?” as if it were an option on the list for that move. On a 7–9, they take a String on you instead of asking a question back. Say why. Do they just smell that good or that fearsome?",
					rolled: "yes",
					rolldefault: "heart"
				},
			]
		},
		"chosen": { 
			name: "The Chosen",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			}
		},
		"devoted": { 
			name: "The Devoted",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			},
			moves: [
				{
					name: "Loyal Steed",
					body: "Name your steed and detail two strengths and two weaknesses from the lists given. When riding your steed, you may roll +Spirit to Fight and may take a person with you whenever you Defy Disaster.",
					rolled: "yes",
					rolldefault: "spirit",
					blanks: [
						{
							name: "Strengths",
							suggestions: "unthreatening, fast and agile, dangerous attack, hardy, stealthy, mental bond, flying (counts as both strength choices unless flight is common)"
						},
						{
							name: "Weaknesses",
							suggestions: "unusual diet, conspicuous, plodding, harmless, stubborn, collateral damage, vulnerable to something common"
						}
					]
				}
			]
		},
		"infamous": { 
			name: "The Infamous",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			}
		},
		"nature witch": { 
			name: "The Nature Witch",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			}
		},
		"scoundrel": { 
			name: "The Scoundrel",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			},
			moves: [
				{
					name: "Heat of the Moment",
					body: "When you taunt someone into doing something they want to do but find unwise, roll +Daring:",
					rolled: "yes",
					rolldefault: "daring",
					preamble: "If the target is an NPC:",
					hit: "They'll do it in exchange for a small concession or reassurance",
					mixed: "They choose 1",
					mixedbullets: [
						"Create an opportunity for you or your allies",
						"They give you a String on them",
					],
					alternative: "If the target is a PC:",
					althit: "They mark XP if they do it, and must take a Condition if they don't",
					altmixed: "You choose 1",
					altmixedbullets: [
						"They mark XP if they do it",
						"They take a Condition if they don't"
					],
					end: "For either a PC or an NPC, if you aren’t already Smitten with them, you may choose to treat a 7–9 result as a 10+ by choosing to become Smitten with the target.",
					pbdefault: "yes"
				}
			],
		},
		"seeker": { 
			name: "The Seeker",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			}
		},
		"spooky witch": { 
			name: "The Spooky Witch",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			},
			moves: [
				{
					name: "Commune with the Unseen",
					body: "When you perform a ritual to commune with the Unseen, give a dangerous Unseen a String on you and roll +Spirit:",
					rolled: "yes",
					rolldefault: "spirit",
					hit: "Choose 2",
					hitbullets: [
						"Hide something in the Unseen world",
						"Learn something important from the Unseen",
						"Temporarily alter the Unseen nature of a place",
						"Ask a question from Figure Out a Person of anyone, anywhere, if you can name one of their deceased loved ones",
						"Learn the recent history of an object you hold"
					],
					mixed: "Choose 2 from the 10+ list, but choose 1 thing that goes awry",
					mixedbullets: [
						"Restless Unseen cause a haunting",
						"Hungry Unseen destroy all non-sentient life in a small area",
						"Stern Unseen judge you, inflicting a Condition"
					],
					pbdefault: "yes",
					pbother: "no"
				}
			],
		},
		"trickster": { 
			name: "The Trickster",
			look: {
				demeanor: "",
				clothes: "",
				sword: ""
			}
		}
	};

	// event handlers
	
	// Initialize when first opening the sheet, or when the initializing field is changed appropriately.

	on("sheet:opened change:pbinitialized", function() {
		log("sheet:opened");
		getAttrs(["pbinitialized"], function(values) {
			var attrs = { "pbinitialized": "yes" };
			if ( values.pbinitialized !== "yes" ) {
				log("pbinitialized is not yes");
				if ( values.pbinitialized === "reset" ) {
					log("Will use idarray length here.");
					attrs["movesinstructions"] = "";
					getSectionIDs("repeating_playbooks", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_playbooks_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_looks", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_looks_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_stats", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_stats_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_startingstats", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_startingstats_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_advances", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_advances_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_moves", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_moves_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_conditions", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_conditions_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_strings", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_strings_"+idarray[i]);
						}
					});
					getSectionIDs("repeating_modifiers", function(idarray) {
						for(var i=0; i < idarray.length; i++ ) {
							removeRepeatingRow("repeating_modifiers_"+idarray[i]);
						}
					});
					attrs["playbook-current-row"] = "";
					attrs["starting-chosen"] = "0";
					attrs["experience"] = 0; attrs["xp1"] = 0; attrs["xp2"] = 0; attrs["xp3"] = 0; attrs["xp4"] = 0; attrs["xp5"] = 0;
				}
				attrs["playbook-key"] = "";
				attrs["playbook-name"] = gTBK("Choose a playbook!");
				attrs["experience_max"] = xpmax;
				var stringid = "repeating_strings_" + generateActuallyUniqueRowID();
				attrs[`${stringid}_used`] = "no"; // Creates our starter String entry
				var modifierid = "repeating_modifiers_" + generateActuallyUniqueRowID();
				attrs[`${modifierid}_used`] = "no"; // Creates our starter modifier entry
				attrs["rollprompt"] = "?{roll with modifier +/-?|0}"; // sets up our default rolling prompt
				for(var [id,value] of Object.entries(playbooks) ) {
					var newid = generateActuallyUniqueRowID();
					var pbidpre = "repeating_playbooks_" + newid + "_";
					var pbidkey = pbidpre + "key";
					var pbidname = pbidpre + "name";
					attrs[pbidkey] = id;
					attrs[pbidname] = gTBK(value["name"]);

					// We also need to create all the moves for all the playbooks within the data model, so they're available for selection. 
					if ( typeof value["moves"] !== "undefined" ) {
						log("We have defined moves.");
						var mymoves = value["moves"];
						log(mymoves);
						for(var i=0; i < mymoves.length; i++ ) {
							if ( i === 0 ) {
								// then we need to insert a subheader that identifies the playbook moves
								// this is a solo entry that doesn't actually contain a move, needs its own id
								var subid = generateActuallyUniqueRowID();
								var subidpre = "repeating_moves_" + subid + "_";
								attrs[`${subidpre}playbook`] = id;
								attrs[`${subidpre}subheader`] = gTBK(playbooks[id].name) + " " + gTBK("Playbook Moves");
								attrs[`${subidpre}pbdefault`] = "yes";
								attrs[`${subidpre}pbother`] = "yes";
								attrs[`${subidpre}show`] = "no";
							}
							var mymove = mymoves[i];
							var moveid = generateActuallyUniqueRowID();
							var moveidpre = "repeating_moves_" + moveid + "_";
							attrs[`${moveidpre}name`] = gTBK(mymove.name);
							attrs[`${moveidpre}playbook`] = id; // the playbook key value
							attrs[`${moveidpre}body`] = gTBK(mymove.body);
							attrs[`${moveidpre}taken`] = "";
							if ( typeof mymove.header !== "undefined" ) { attrs[`${moveidpre}header`] = gTBK(mymove.header); }
							if ( typeof mymove.subheader !== "undefined" ) { attrs[`${moveidpre}subheader`] = gTBK(mymove.subheader); }
							if ( typeof mymove.pbdefault !== "undefined" ) { attrs[`${moveidpre}pbdefault`] = mymove.pbdefault; }
							if ( typeof mymove.pbother !== "undefined" ) { attrs[`${moveidpre}pbother`] = mymove.pbother; }
							if ( typeof mymove.preamble !== "undefined" ) { attrs[`${moveidpre}preamble`] = gTBK(mymove.preamble); }
							if ( typeof mymove.end !== "undefined" ) { attrs[`${moveidpre}end`] = gTBK(mymove.end); }
							if ( typeof mymove.hit !== "undefined" ) { attrs[`${moveidpre}hit`] = gTBK(mymove.hit); }
							if ( typeof mymove.mixed !== "undefined" ) { attrs[`${moveidpre}mixed`] = gTBK(mymove.mixed); }
							if ( typeof mymove.miss !== "undefined" ) { attrs[`${moveidpre}miss`] = gTBK(mymove.miss); }
							if ( typeof mymove.alternative !== "undefined" ) { attrs[`${moveidpre}alternative`] = gTBK(mymove.alternative); }
							if ( typeof mymove.althit !== "undefined" ) { attrs[`${moveidpre}althit`] = gTBK(mymove.althit); }
							if ( typeof mymove.altmixed !== "undefined" ) { attrs[`${moveidpre}altmixed`] = gTBK(mymove.altmixed); }
							if ( typeof mymove.altmiss !== "undefined" ) { attrs[`${moveidpre}altmiss`] = gTBK(mymove.altmiss); }
							if ( typeof mymove.rolled !== "undefined" && mymove.rolled === "yes" ) { 
								log("This is a rolled move.");
								var rc = "";
								if ( typeof mymove.rolldefault !== "undefined" ) {
									log("There is a default attribute");
									if ( typeof stats[mymove.rolldefault] !== "undefined" ) {
										rc = "|" + gTBK(stats[mymove.rolldefault]) + " " + gTBK("(Default)") + ",@{stat_" + mymove.rolldefault + "}";
									}
								} 
								// building a string like |Sharp (Default),@{Sharp}|Charm,@{Charm}|Cool,@{Cool}|Sharp,@{Sharp}|Tough,@{Tough}|Weird,@{Weird}
								for(var [statkey,statname] of Object.entries(stats)) {
									rc = rc + "|" + gTBK(statname) + ",@{stat_" + statkey + "}";
								}
								log(rc);
								attrs[`${moveidpre}rollconfig`] = rc;
							}
							// Now the expanding modulars: the blanks, and the bullets 
							var mbullets = [ "bullets", "hitbullets", "mixedbullets", "missedbullets", "altbullets", "althitbullets", "altmixedbullets", "altmissedbullets" ];
							for(var j=0; j < 5; j++) {
								if ( typeof mymove.blanks !== "undefined" ) { 
									if ( typeof mymove.blanks[j] !== "undefined" ) {
										attrs[`${moveidpre}blankname${j}`] = gTBK(mymove.blanks[j].name);
										if ( typeof mymove.blanks[j].suggestions !== "undefined" ) {
											attrs[`${moveidpre}blanksuggestions${j}`] = gTBK(mymove.blanks[j].suggestions); 
										}
									}
								}
								// This will run us through the 7 modular bullet lists for this index (!!!!!!) 
								for(var x=0; x < mbullets.length; x++) {
									var fkey = mbullets[x];
									if ( typeof mymove[fkey] !== "undefined" ) { // Then there's an bullet list of this type for this move
										var flist = mymove[fkey];
										var nosattheend = fkey.substring(0,fkey.length-1);
										if ( typeof flist[j] !== "undefined" ) { // Then there's a bullet at this position in this list
											attrs[`${moveidpre}${nosattheend}${j}`] = gTBK(flist[j]);
										}
									}
								}
							}
						}
					}
				}
				// Here endeth the move creation section

				// We also need to create all the basic moves. These are very similar to playbook moves, but we're gonna replicate code in case differences emerge over development.

				var basicids = {};

				for(var i=0; i < basicmoves.length; i++ ) {
					var basicmove = basicmoves[i];
					var moveid = generateActuallyUniqueRowID();
					var moveidpre = "repeating_moves_" + moveid + "_";
					if ( typeof basicmove.name !== "undefined" ) { 
						attrs[`${moveidpre}name`] = gTBK(basicmove.name); 
						basicids[attrs[`${moveidpre}name`]] = moveid; // helps us map for later
					}
					if ( typeof basicmove.body !== "undefined" ) { attrs[`${moveidpre}body`] = gTBK(basicmove.body); }
					attrs[`${moveidpre}taken`] = "yes";
					attrs[`${moveidpre}show`] = "yes";
					if ( typeof basicmove.header !== "undefined" ) { attrs[`${moveidpre}header`] = gTBK(basicmove.header); }
					if ( typeof basicmove.subheader !== "undefined" ) { attrs[`${moveidpre}subheader`] = gTBK(basicmove.subheader); }
					if ( typeof basicmove.preamble !== "undefined" ) { attrs[`${moveidpre}preamble`] = gTBK(basicmove.preamble); }
					if ( typeof basicmove.end !== "undefined" ) { attrs[`${moveidpre}end`] = gTBK(basicmove.end); }
					if ( typeof basicmove.hit !== "undefined" ) { attrs[`${moveidpre}hit`] = gTBK(basicmove.hit); }
					if ( typeof basicmove.mixed !== "undefined" ) { attrs[`${moveidpre}mixed`] = gTBK(basicmove.mixed); }
					if ( typeof basicmove.miss !== "undefined" ) { attrs[`${moveidpre}miss`] = gTBK(basicmove.miss); }
					if ( typeof basicmove.alternative !== "undefined" ) { attrs[`${moveidpre}alternative`] = gTBK(basicmove.alternative); }
					if ( typeof basicmove.althit !== "undefined" ) { attrs[`${moveidpre}althit`] = gTBK(basicmove.althit); }
					if ( typeof basicmove.altmixed !== "undefined" ) { attrs[`${moveidpre}altmixed`] = gTBK(basicmove.altmixed); }
					if ( typeof basicmove.altmiss !== "undefined" ) { attrs[`${moveidpre}altmiss`] = gTBK(basicmove.altmiss); }
					if ( typeof basicmove.rolled !== "undefined" && basicmove.rolled === "yes" ) { 
						log("This is a rolled move.");
						var rc = "";
						if ( typeof basicmove.rolldefault !== "undefined" ) {
							log("There is a default attribute");
							if ( typeof stats[basicmove.rolldefault] !== "undefined" ) {
								rc = "|" + stats[basicmove.rolldefault] + " " + gTBK("(Default)") + ",@{stat_" + basicmove.rolldefault + "}";
							}
						} 
						// building a string like |Sharp (Default),@{Sharp}|Charm,@{Charm}|Cool,@{Cool}|Sharp,@{Sharp}|Tough,@{Tough}|Weird,@{Weird}
						for(var [statkey,statname] of Object.entries(stats)) {
							rc = rc + "|" + gTBK(statname) + ",@{stat_" + statkey + "}";
						}
						log(rc);
						attrs[`${moveidpre}rollconfig`] = rc;
					}
					// Now the expanding modulars: the blanks, and the bullets 
					var mbullets = [ "bullets", "hitbullets", "mixedbullets", "missedbullets", "altbullets", "althitbullets", "altmixedbullets", "altmissedbullets" ];
					for(var j=0; j < 5; j++) {
						if ( typeof basicmove.blanks !== "undefined" ) { 
							if ( typeof basicmove.blanks[j] !== "undefined" ) {
								attrs[`${moveidpre}blankname${j}`] = gTBK(basicmove.blanks[j].name);
								if ( typeof basicmove.blanks[j].suggestions !== "undefined" ) {
									attrs[`${moveidpre}blanksuggestions${j}`] = gTBK(basicmove.blanks[j].suggestions); 
								}
							}
						}
						// This will run us through the 7 modular bullet lists for this index (!!!!!!) 
						for(var x=0; x < mbullets.length; x++) {
							var fkey = mbullets[x];
							if ( typeof basicmove[fkey] !== "undefined" ) { // Then there's an bullet list of this type for this move
								var flist = basicmove[fkey];
								var nosattheend = fkey.substring(0,fkey.length-1);
								if ( typeof flist[j] !== "undefined" ) { // Then there's a bullet at this position in this list
									attrs[`${moveidpre}${nosattheend}${j}`] = gTBK(flist[j]);
								}
							}
						}
					}
				}
				// Here endeth basic moves creation
				for(var [id,value] of Object.entries(looks) ) {
					var newid = generateActuallyUniqueRowID();
					var lookpre = "repeating_looks_" + newid + "_";
					var lookkey = lookpre + "key";
					var lookname = lookpre + "name";
					attrs[lookkey] = gTBK(id);
					attrs[lookname] = gTBK(value);
				}
				var rc = "";
				for(var [id,value] of Object.entries(stats) ) {
					var newid = generateActuallyUniqueRowID();
					var statpre = "repeating_stats_" + newid + "_";
					var statkey = statpre + "key";
					var statname = statpre + "name";
					var statdesc = statpre + "description";
					attrs[statkey] = id;
					attrs[statname] = gTBK(value);
					attrs[statdesc] = gTBK(sdesc[id]);
					// building a string like |@{Sharp}|Charm,@{Charm}|Cool,@{Cool}|Sharp,@{Sharp}|Tough,@{Tough}|Weird,@{Weird}
					rc = rc + "|" + gTBK(value) + ",@{stat_" + id + "}";
				}
				attrs["stats-query"] = rc;
				// usefully, conditions creation comes after moves creation, so we can map these to their affected moves too
				for(var [id,value] of Object.entries(conditions) ) {
					var newid = generateActuallyUniqueRowID();
					var conpre = "repeating_conditions_" + newid + "_";
					for(var [fid,fval] of Object.entries(value)) {
						var fkey = conpre + fid;
						attrs[fkey] = fval;
						if ( fid === "name" ) { var fvt = gTBK(fval); attrs[fkey] = fvt; attrs[`condition-${fvt}`] = "no"; }
						if ( fid === "penalized" ) { 
							var fvt = gTBK(fval); attrs[fkey] = fvt; 
							attrs[`condition-penalty-${fvt}`] = 0;
							if ( typeof basicids[fvt] !== "undefined" ) {
								var movefieldid = basicids[fvt];
								attrs[`${conpre}moveid`] = movefieldid; // build that link 
								attrs[`${movefieldid}conditionid`] = newid; // build that link other direction
								attrs[`${movefieldid}condition-marked`] = "no"; // Initialize
							}
						}
						if ( fid === "clearwhen" ) { var fvt = gTBK(fval); attrs[fkey] = fvt; }
					}
				}
				for(var i = 0; i < advances.length; i++) {
					var newid = generateActuallyUniqueRowID();
					var apre = "repeating_advances_" + newid + "_";
					var advance = advances[i];
					var tid = apre + "text";
					// var lid = apre + "notelabel";
					var pid = apre + "preamble";
					attrs[tid] = gTBK(advance.text);
					if ( typeof advance.preamble !== "undefined" ) { attrs[pid] = gTBK(advance.preamble); }
					// if ( typeof advance.notelabel !== "undefined" ) { attrs[lid] = gTBK(advance.notelabel); }
				}
				log(attrs);
				setAttrs(attrs);
			}
		});
	});

	// Do everything that needs to be done when picking a playbook from the menu

	on("clicked:repeating_playbooks:choose-playbook", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-15); // Strips off the 'choose-playbook'
		var keyid = rowprefix + "key";
		var nameid = rowprefix + "name";
		var selectedid = rowprefix + "selected";
		getAttrs([keyid,nameid,"playbook-current-row"], function(a) {
			var attrs = { "playbook-key": a[keyid], "playbook-name": a[nameid], "playbook-current-row": rowprefix };
			if ( a["playbook-current-row"] !== "" ) {
				var oldselectedid = a["playbook-current-row"] + "selected";
				attrs[oldselectedid] = "";
			}
			attrs[selectedid] = "S"; // S for a star, k for a heart
			attrs["playbook-current-row"] = rowprefix;
			attrs["movesinstructions"] = "";
			if ( typeof playbooks[a[keyid]].movesinstructions !== "undefined" ) {
				attrs["movesinstructions"] = gTBK(playbooks[a[keyid]].movesinstructions);
			}
			setAttrs(attrs);

			// Looks section 

			var mylooks = playbooks[a[keyid]].look;

			getSectionIDs("looks", function(lf) {
				var lfields = [];
				for(var i=0; i < lf.length; i++ ) {
					lfields[i] = "repeating_looks_" + lf[i] + "_key";
				}

				getAttrs(lfields, function(la) {
					var lattrs = {};
					for(var i=0; i < lfields.length; i++) {

						var key = la[lfields[i]]; // the value of the look's key field tells us what category we're looking to populate examples for
						if ( typeof mylooks[key] !== "undefined" ) {
							// Then we have a look category key to populate!
							var eid = "repeating_looks_" + lf[i] + "_examples";
							lattrs[eid] = mylooks[key];
						}
					}
					setAttrs(lattrs);
				});

			});
			
			// starting stats section

			var mystarts = playbooks[a[keyid]].startstats;
			log(mystarts);
			log(a[keyid]);
			log(playbooks[a[keyid]]);

			// Clear out any existing starting stats sets, they don't matter
			getSectionIDs("repeating_startingstats", function(idarray) {
				for(var i=0; i < idarray.length; i++ ) {
					removeRepeatingRow("repeating_startingstats_"+idarray[i]);
				}
			});
			
			// Now populate based on our mystarts

			var starta = {};
			if ( typeof mystarts !== "undefined" ) {
				for(var i=0; i < mystarts.length; i++) {
					var newid = generateActuallyUniqueRowID();
					var startpre = "repeating_startingstats_"+newid+"_";
					var startset = startpre + "set";
					var starttext = startpre + "text";
					var myset = ""; 
					var mytext = "";
					for(var [statkey,value] of Object.entries(mystarts[i]) ) {
						if ( myset !== "" ) {
							myset = myset+" ";
							mytext = mytext+", ";
						}
						myset = myset+statkey+":"+value;
						mytext = mytext+gTBK(stats[statkey])+" ";
						if ( Number(value) > 0 ) {
							mytext = mytext+"+";
						} else if ( Number(value) == 0 ) {
							mytext = mytext+"=";
						}
						mytext = mytext+value;
					}
					starta[startset] = myset;
					starta[starttext] = mytext;
				}
			
				setAttrs(starta);
			}

			// Moves section 

			getSectionIDs("moves", function(mf) {
				log(mf);
				var mfields = [];
				for(var i=0; i < mf.length; i++ ) {
					mfields[i*4] = "repeating_moves_" + mf[i] + "_playbook";
					mfields[i*4+1] = "repeating_moves_" + mf[i] + "_pbdefault";
					mfields[i*4+2] = "repeating_moves_" + mf[i] + "_taken";
					mfields[i*4+3] = "repeating_moves_" + mf[i] + "_name";
				}

				getAttrs(mfields, function(ma) {
					var mattrs = {};
					for(var i=0; i < mf.length; i++) {
						var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
						var mdefid = "repeating_moves_" + mf[i] + "_pbdefault"; var mdef = ma[mdefid];
						var takeid = "repeating_moves_" + mf[i] + "_taken";
						var showid = "repeating_moves_" + mf[i] + "_show";
						var nameid = "repeating_moves_" + mf[i] + "_name"; var mname = ma[nameid];
						// Decide if we mark as taken any default moves for the playbook, and clear out marked ones from viewing other playbooks previously.
						if ( mdef === "yes" ) {
							if ( mbook === attrs["playbook-key"] ) { // Then this is a default move for the chosen playbook
								mattrs[takeid] = "yes"; ma[takeid] = "yes"; // need to set both the attribute-to-be, and tell later processes that the attribute-that-is is already the attribute-to-be's value
							} else { // Then this is a default move for ANOTHER playbook and should get un-chosen
								mattrs[takeid] = "0"; ma[takeid] = "0"; // see above
							}
						}
						mattrs[`move-${mbook}-${mname}`] = ma[takeid]; // Set up the externalized tracking of moves
						// Default to displaying only moves from the playbook
						if ( mbook === attrs["playbook-key"] || ma[takeid] === "yes" ) { // If it's marked taken still/already at this point (after checking for playbook defaults), it should not be unmarked!
							mattrs[showid] = "yes";
						} else {
							mattrs[showid] = "no"; // for now; eventually we may have differing behaviors depending on current display settings
						}
					}
					log(mattrs);
					setAttrs(mattrs);

				});

			});

		});
	});

	// Sharing support for moves; we must be able to know when a field is blank, and not include it in the share formula.
	
	var moveoptions = ["alternative", "altbullet0", "altbullet1", "altbullet2", "altbullet3", "altbullet4", "althit", "althitbullet0", "althitbullet1", "althitbullet2", "althitbullet3", "althitbullet4", "altmiss", "altmissbullet0", "altmissbullet1", "altmissbullet2", "altmissbullet3", "altmissbullet4", "altmixed", "altmixedbullet0", "altmixedbullet1", "altmixedbullet2", "altmixedbullet3", "altmixedbullet4", "blankname0", "blankname1", "blankname2", "blankname3", "blankname4", "bullet0", "bullet1", "bullet2", "bullet3", "bullet4", "end", "hit", "hitbullet0", "hitbullet1", "hitbullet2", "hitbullet3", "hitbullet4", "miss", "missbullet0", "missbullet1", "missbullet2", "missbullet3", "missbullet4", "mixed", "mixedbullet0", "mixedbullet1", "mixedbullet2", "mixedbullet3", "mixedbullet4", "preamble"]; // special cases: "blank0", "blank1", "blank2", "blank3", "blank4"
	
	on("change:repeating_moves:name", function(e) { // if a name is changed, then the move's been created, so we should make sure to prep its share button
		var moveprefix = (e.sourceAttribute).slice(0,-4); // Strips off the 'name'
		var grabs = []; var sets = {};
		for(var i=0; i < moveoptions.length; i++) {
			grabs[i] = moveprefix + moveoptions[i];
		}
		var shareoptid = moveprefix + "shareoptions";
		getAttrs(grabs,function(m) {
			var options = "{{blank0=@{blank0}}} {{blank1=@{blank1}}} {{blank2=@{blank2}}} {{blank3=@{blank3}}} {{blank4=@{blank4}}} ";
			for(var i=0; i < moveoptions.length; i++) {
				var id = moveprefix + moveoptions[i];
				if ( typeof m[id] !== "undefined" && m[id] !== "" ) {
					options = options + "{{"+moveoptions[i]+"=@{"+moveoptions[i]+"}}} ";
				}
			}
			sets[shareoptid] = options;
			setAttrs(sets);
		});
	});

	// There are three filter modes for moves
	
	on("clicked:movefilter-pbmoves", function() {
		getSectionIDs("moves", function(mf) {
			log(mf);
			var mfields = ["playbook-key"];
			for(var i=0; i < mf.length; i++ ) {
				mfields[i*3+1] = "repeating_moves_" + mf[i] + "_playbook";
				mfields[i*3+2] = "repeating_moves_" + mf[i] + "_pbdefault";
				mfields[i*3+3] = "repeating_moves_" + mf[i] + "_taken";
			}
			getAttrs(mfields, function(ma) {
				var mattrs = {};
				for(var i=0; i < mf.length; i++) {
					var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
					var mdefid = "repeating_moves_" + mf[i] + "_pbdefault"; var mdef = ma[mdefid];
					var takeid = "repeating_moves_" + mf[i] + "_taken";
					var showid = "repeating_moves_" + mf[i] + "_show";
					if ( mbook === ma["playbook-key"] || ma[takeid] === "yes" ) { // If it's marked taken or it's in the active playbook, show it
						mattrs[showid] = "yes";
					} else { // if it's not, hide it
						mattrs[showid] = "no";
					}
				}
				log(mattrs);
				setAttrs(mattrs);
			});
		});
	});
	
	on("clicked:movefilter-takenonly", function() {
		getSectionIDs("moves", function(mf) {
			log(mf);
			var mfields = ["playbook-key"];
			for(var i=0; i < mf.length; i++ ) {
				mfields[i*3+1] = "repeating_moves_" + mf[i] + "_playbook";
				mfields[i*3+2] = "repeating_moves_" + mf[i] + "_pbdefault";
				mfields[i*3+3] = "repeating_moves_" + mf[i] + "_taken";
			}
			getAttrs(mfields, function(ma) {
				var mattrs = {};
				for(var i=0; i < mf.length; i++) {
					var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
					var mdefid = "repeating_moves_" + mf[i] + "_pbdefault"; var mdef = ma[mdefid];
					var takeid = "repeating_moves_" + mf[i] + "_taken";
					var showid = "repeating_moves_" + mf[i] + "_show";
					if ( ma[takeid] === "yes" ) { // If it's marked taken, show it
						mattrs[showid] = "yes";
					} else { // if it's not, hide it
						mattrs[showid] = "no";
					}
				}
				log(mattrs);
				setAttrs(mattrs);
			});
		});
	});
	
	on("clicked:movefilter-allmoves", function() {
		getSectionIDs("moves", function(mf) {
			log(mf);
			var mfields = ["playbook-key"];
			for(var i=0; i < mf.length; i++ ) {
				mfields[i*3+1] = "repeating_moves_" + mf[i] + "_playbook";
				mfields[i*3+2] = "repeating_moves_" + mf[i] + "_pbdefault";
				mfields[i*3+3] = "repeating_moves_" + mf[i] + "_taken";
			}
			getAttrs(mfields, function(ma) {
				var mattrs = {};
				for(var i=0; i < mf.length; i++) {
					var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
					var mdefid = "repeating_moves_" + mf[i] + "_pbdefault"; var mdef = ma[mdefid];
					var takeid = "repeating_moves_" + mf[i] + "_taken";
					var showid = "repeating_moves_" + mf[i] + "_show";
					mattrs[showid] = "yes"; // Show everything.
				}
				log(mattrs);
				setAttrs(mattrs);
			});
		});
	});

	on("clicked:repeating_playbooks:movefilter-onepb", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-16); // Strips off the 'movefilter-onepb'
		getAttrs([`${rowprefix}key`], function(kf) {
			getSectionIDs("moves", function(mf) {
				log(mf);
				var mfields = ["playbook-key"];
				for(var i=0; i < mf.length; i++ ) {
					mfields[i*3+1] = "repeating_moves_" + mf[i] + "_playbook";
					mfields[i*3+2] = "repeating_moves_" + mf[i] + "_pbdefault";
					mfields[i*3+3] = "repeating_moves_" + mf[i] + "_taken";
				}
				getAttrs(mfields, function(ma) {
					var mattrs = {};
					for(var i=0; i < mf.length; i++) {
						var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
						var mdefid = "repeating_moves_" + mf[i] + "_pbdefault"; var mdef = ma[mdefid];
						var takeid = "repeating_moves_" + mf[i] + "_taken";
						var showid = "repeating_moves_" + mf[i] + "_show";
						if ( mbook === kf[`${rowprefix}key`] || ma[takeid] === "yes" ) { // If it's marked taken or it's in the active playbook or it's in the kf indicated playbook, show it
							mattrs[showid] = "yes";
						} else if ( mbook === ma["playbook-key"] ) {
							// Nothing happens; existing value should be left as-is. (Respecting user's prior choice for showing or not showing untakens in their playbook.)
						} else { // if it's not, hide it
							mattrs[showid] = "no";
						}
					}
					log(mattrs);
					setAttrs(mattrs);
				});
			});
		});
	});

	on("change:movefilter-hidebasic", function() {
		getSectionIDs("moves", function(mf) {
			log(mf);
			var mfields = ["playbook-key","movefilter-hidebasic"];
			for(var i=0; i < mf.length; i++ ) {
				mfields[i*2+2] = "repeating_moves_" + mf[i] + "_playbook";
				mfields[i*2+3] = "repeating_moves_" + mf[i] + "_header"; // if this is not null or empty, then we need to do a little extra
			}
			getAttrs(mfields, function(ma) {
				var mattrs = {};
				for(var i=0; i < mf.length; i++) {
					var mbookid = "repeating_moves_" + mf[i] + "_playbook"; var mbook = ma[mbookid];
					var headid = "repeating_moves_" + mf[i] + "_header"; var head = ma[headid];
					var takeid = "repeating_moves_" + mf[i] + "_taken";
					var showid = "repeating_moves_" + mf[i] + "_show";
					var state = "yes";
					if ( typeof ma["movefilter-hidebasic"] !== "undefined" && ma["movefilter-hidebasic"] === "yes" ) {
						state = "no";
					}
					if ( mbook === "" ) { // If it has no playbook, it's a basic move; for this handler, these are the only moves we care about
						mattrs[showid] = state;
						mattrs[takeid] = state;
					}
				}
				log(mattrs);
				setAttrs(mattrs);
			});
		});
	});

	// A set of starting stats has been picked. Get going.

	on("clicked:repeating_startingstats:choose-startingstats", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-20); // Strips off the 'choose-startingstats'
		var setid = rowprefix + "set";
		getAttrs(["starting-chosen", setid], function(a) {
			if ( typeof a["starting-chosen"] === "undefined" || a["starting-chosen"] === "0" ) { // Then we may proceed, otherwise buttons are locked
				var statspec = a[setid];
				var statmap = {};
				log("statspec, splitting");
				var statspeclist = statspec.toString().split(/ /);
				log(statspec);
				for(var j=0; j < statspeclist.length; j++ ) {
					var parts = statspeclist[j].toString().split(/:/);
					var statkey = parts[0];
					var statval = parts[1];
					statmap[statkey] = statval;
				}
				log(statmap);
				getSectionIDs("stats", function(sf) {
					log(sf);
					var sfields = [];
					for(var i=0; i < sf.length; i++ ) {
						sfields[i] = "repeating_stats_" + sf[i] + "_key";
					}
					log(sfields);
					getAttrs(sfields,function(sa) {
						log(sa);
						var sattrs = { "starting-chosen": "yes" };
						for(var i=0; i < sfields.length; i++) {
							var key = sa[sfields[i]];
							if ( typeof statmap[key] !== "undefined" ) {
								var rateid = "repeating_stats_" + sf[i] + "_rating";
								sattrs[rateid] = statmap[key];
							}
						}
						log(sattrs);
						setAttrs(sattrs);
					});
				});
			} else {
				log("Starting stat choice was already made, current stats menu is locked.");
			}
		});
	});

	// Conditions -> Modifiers
	
	on("change:repeating_conditions:marked", function(e) {
		var rowid = (e.sourceAttribute).slice(0,-6); // Strips off the 'marked';
		var markedid = `${rowid}marked`;
		var nameid = `${rowid}name`;
		var penaltyid = `${rowid}penalty`;
		var moveidid = `${rowid}moveid`;
		var penalizedid = `${rowid}penalized`;
		getAttrs([nameid,markedid,penaltyid,penalizedid,moveidid],function(m) {
			var marked = m[markedid];
			var name = m[nameid];
			var penalty = m[penaltyid];
			var penalized = m[penalizedid];
			if ( typeof marked !== "undefined" && marked === "yes" ) {
				// then it is marked, and we need to create a modifier matching it
				var sattrs = {};
				var modifierid = "repeating_modifiers_" + generateActuallyUniqueRowID();
				sattrs[`${modifierid}_used`] = "yes";
				sattrs[`${modifierid}_condition-id`] = rowid;
				sattrs[`${modifierid}_modifier`] = penalty;
				sattrs[`${modifierid}_state`] = "ongoing";
				sattrs[`${modifierid}_target`] = penalized + ' ('+name+')';
				if ( typeof m[moveidid] !== "undefined" && m[moveidid] !== "" ) {
					var moveid = m[moveidid];
					sattrs[`repeating_moves_${moveid}_condition-marked`] = "yes";
				}
				// We'll also want to flip a flag on the relevant basic move entry.
				setAttrs(sattrs);
			} else {
				// then it is unmarked, and we need to make sure we do not retain a modifier matching it
				// rowid contains the condition's id; we need to find all modifiers that match it in case there was a misfire that caused it to get populated to the list twice
				getSectionIDs("repeating_modifiers", function(idarray) {
					var mids = [];
					for(var i=0; i < idarray.length; i++ ) {
						mids[i] = "repeating_modifiers_" + idarray[i] + "_condition-id";
					}
					getAttrs(mids,function(mdf) {
						var u = {};
						for(var i=0; i < idarray.length; i++ ) {
							if ( mdf[mids[i]] === rowid ) {
								// reality is, this should work but doesn't because roll20 can't be bothered to fire off its own remove event, so, workaround time
								// removeRepeatingRow("repeating_modifiers_"+idarray[i]);
								var uid = "repeating_modifiers_"+idarray[i]+"_used";
								var mid = "repeating_modifiers_"+idarray[i]+"_modifier";
								u[uid] = "delete";
								u[mid] = "0";
							}
						}
						// We also need to attend to flipping off the flag that was on the associated move, if any
						if ( typeof m[moveidid] !== "undefined" && m[moveidid] !== "" ) {
							var moveid = m[moveidid];
							u[`repeating_moves_${moveid}_condition-marked`] = "no";
						}
						setAttrs(u);
					});
				});
			}
		});
	});
	
	// Modifiers stuff

	/* attr_state, act_state */

	on("clicked:mods-checkall", function() {
		getSectionIDs("repeating_modifiers", function(idarray) {
			mlist = [];
			for(var i=0; i < idarray.length; i++ ) {
				mlist[i] = "repeating_modifiers_"+idarray[i]+"_used";
			}
			getAttrs(mlist, function(m) {
				var mattrs = {};
				for(var i=0; i < idarray.length; i++ ) {
					var uid = "repeating_modifiers_"+idarray[i]+"_used"; 
					var u = m[uid];
					var rid = "repeating_modifiers_"+idarray[i]+"_rollmod"; 
					if ( typeof u !== "undefined" && u === "yes" ) {
						mattrs[rid] = "yes"; 
					}
				}
				setAttrs(mattrs);
			});
		});
	});

	on("clicked:mods-uncheckall", function() {
		getSectionIDs("repeating_modifiers", function(idarray) {
			mlist = [];
			for(var i=0; i < idarray.length; i++ ) {
				mlist[i] = "repeating_modifiers_"+idarray[i]+"_used";
			}
			getAttrs(mlist, function(m) {
				var mattrs = {};
				for(var i=0; i < idarray.length; i++ ) {
					var uid = "repeating_modifiers_"+idarray[i]+"_used"; 
					var u = m[uid];
					var rid = "repeating_modifiers_"+idarray[i]+"_rollmod"; 
					if ( typeof u !== "undefined" && u === "yes" ) {
						mattrs[rid] = "no"; 
					}
				}
				setAttrs(mattrs);
			});
		});
	});

	on("clicked:repeating_modifiers:state", function(e) {
		var rowid = (e.sourceAttribute).slice(0,-5); // Strips off the 'state';
		log(`Toggling state for modifier ${rowid}`);
		var stateid = `${rowid}state`; // attr_state and act_state effectively have the same id, I think? but let's reconstruct.
		var statenid = `${rowid}statename`; // grab the name of the state too
		getAttrs([stateid],function(s) {
			log(s);
			var sattrs = {};
			if ( s[stateid] === "forward" ) {
				sattrs[stateid] = "ongoing";
				sattrs[statenid] = gTBK("ongoing");
			} else {
				sattrs[stateid] = "forward";
				sattrs[statenid] = gTBK("forward");
			}
			log(sattrs);
			setAttrs(sattrs);
		});
	});

	on("clicked:repeating_modifiers:trash", function(e) {
		var rowid = (e.sourceAttribute).slice(0,-6); // Strips off the '_trash';
		log(`Setting deletion flag for modifier ${rowid}`);
		var sattrs = {};
		sattrs[`${rowid}_used`] = "delete";
		sattrs[`${rowid}_modifier`] = "0"; // This'll make sure the totalling handler will fire off
		setAttrs(sattrs); // Please trigger the handler
	});

	on("change:repeating_modifiers:rollmod change:repeating_modifiers:modifier remove:repeating_modifiers", function() { // this had a blanket change:repeating_modifiers originally, don't think that's right
		log("consequential change detected in repeating_modifiers");
		// We need to examine whether any entries count as unused, and if there are multiples, remove them, and if there are none, add one.
		var mlist = []; var mflist = [];
		getSectionIDs("repeating_modifiers", function(idarray) {
			log("got the ID list");
			log(idarray);
			for(var i=0; i < idarray.length; i++ ) {
				mlist[i] = "repeating_modifiers_"+idarray[i];
				mflist[i*4] = mlist[i] + "_used";
				mflist[i*4+1] = mlist[i] + "_rollmod";
				mflist[i*4+2] = mlist[i] + "_target"; 
				mflist[i*4+3] = mlist[i] + "_modifier"; 
			}
			log("assembled list");
			log(mlist);
			var sattrs = {};
			if ( mlist.length > 0 ) {
				log("list is not empty, so we parse");
				getAttrs(mflist, function(mf) {
					var keeper = false;
					var tally = 0;
					for(var i=0; i < mlist.length; i++ ) {
						var usedid = mlist[i] + "_used"; var used = mf[usedid];
						var rollmodid = mlist[i] + "_rollmod"; var rollmod = mf[rollmodid];
						var targetid = mlist[i] + "_target"; var target = mf[targetid];
						var modifierid = mlist[i] + "_modifier"; var modifier = mf[modifierid];
						if ( used === "delete" ) {
							removeRepeatingRow(mlist[i],{silent:true}); 
						} else if (
							( typeof target === "undefined" || target === "" ) 
							&& ( typeof rollmod === "undefined" || rollmod !== "yes" ) 
							&& ( typeof modifier === "undefined" || modifier === "0" ) 
						) {
							if ( i < (mlist.length - 1) ) {
								// Then it's a blank, no checkmark, 0 modifier, blank target; we only need one of those, and they're interchangeable, so we'll delete these
								removeRepeatingRow(mlist[i],{silent:true}); // We don't need to trigger a bunch of runs through of this handler just because we're removing rows because we are already in this handler
							} else {
								// The exception is if it's the very last one in the list. We don't need to delete that one only to create another every time.
								keeper = true;
								sattrs[usedid] = "no"; 
							}
						} else { 
							sattrs[usedid] = "yes";
							if ( typeof rollmod !== "undefined" && rollmod === "yes" ) { // if we're here, we can also figure out the total of checkmarked stuff
								var mod = 0;
								if ( typeof modifier !== "undefined" ) {
									mod = parseInt(modifier);
									if ( isNaN(mod) ) {
										mod = 0;
									}
									tally = tally + mod;
								}
							}
						}
					}
					// We've exited the for loop, so we can set the modifier tally.
					sattrs["modifier-tally"] = tally;
					// At this point if keeper = true, we don't need to create a new row; if false, we do.
					// Or, if there are no entries, we need to create one, because there always needs to be at least one.
					if ( ! keeper || mlist.length === 0 ) {
						var modifierid = "repeating_modifiers_" + generateActuallyUniqueRowID();
						sattrs[`${modifierid}_used`] = "no"; // Creates our a new modifier entry
					}
					log("Setting attributes for modifiers");
					log(sattrs);
					setAttrs(sattrs,{silent:true}); // We don't need to trigger a bunch of runs through this handler because we're setting attributes *with* this handler.
				});
			} else { // I suspect if there's no array, getAttrs doesn't bother to fire off its callback, which is a shame because I expected it to.
				log("list is empty, so we create");
				var modifierid = "repeating_modifiers_" + generateActuallyUniqueRowID();
				sattrs[`${modifierid}_used`] = "no"; // Creates our a new modifier entry
				log(sattrs);
				setAttrs(sattrs,{silent:true}); // We don't need to trigger a bunch of runs through this handler because we're setting attributes *with* this handler.
			}
		});
	});
	
	// Strings stuff

	on("clicked:repeating_strings:trash", function(e) {
		var rowid = (e.sourceAttribute).slice(0,-6); // Strips off the '_trash';
		log(`Setting deletion flag for string ${rowid}`);
		var sattrs = {};
		sattrs[`${rowid}_used`] = "delete";
		setAttrs(sattrs); // Please trigger the fucking handler
	});

	on("change:repeating_strings remove:repeating_strings", function() {
		log("change detected in repeating_strings");
		// We need to examine whether any entries count as unused, and if there are multiples, remove them, and if there are none, add one.
		var slist = []; var sflist = [];
		getSectionIDs("repeating_strings", function(idarray) {
			log("got the ID list");
			log(idarray);
			for(var i=0; i < idarray.length; i++ ) {
				slist[i] = "repeating_strings_"+idarray[i];
				sflist[i*6] = slist[i] + "_used";
				sflist[i*6+1] = slist[i] + "_check1"; sflist[i*6+2] = slist[i] + "_check2"; sflist[i*6+3] = slist[i] + "_check3"; sflist[i*6+4] = slist[i] + "_check4";
				sflist[i*6+5] = slist[i] + "_target";
			}
			log("assembled list");
			log(slist);
			var sattrs = {};
			if ( slist.length > 0 ) {
				log("list is not empty, so we parse");
				getAttrs(sflist, function(sf) {
					var keeper = false;
					for(var i=0; i < slist.length; i++ ) {
						var usedid = slist[i] + "_used";
						var check1id = slist[i] + "_check1"; var check2id = slist[i] + "_check2"; var check3id = slist[i] + "_check3"; var check4id = slist[i] + "_check4";
						var targetid = slist[i] + "_target";
						var used = sf[usedid]; var check1 = sf[check1id]; var check2 = sf[check2id]; var check3 = sf[check3id]; var check4 = sf[check4id]; var target = sf[targetid];
						if ( used === "delete" ) {
							removeRepeatingRow(slist[i],{silent:true}); 
						} else if (
							( typeof target === "undefined" || target === "" ) 
							&& ( typeof check1 === "undefined" || check1 !== "1" ) 
							&& ( typeof check2 === "undefined" || check2 !== "1" ) 
							&& ( typeof check3 === "undefined" || check3 !== "1" ) 
							&& ( typeof check4 === "undefined" || check4 !== "1" ) 
						) {
							if ( i < (slist.length - 1) ) {
								// Then it's a blank with no used checkboxes; we only need one of those, and they're interchangeable, so we'll delete these
								removeRepeatingRow(slist[i],{silent:true}); // We don't need to trigger a bunch of runs through of this handler just because we're removing rows because we are already in this handler
							} else {
								// The exception is if it's the very last one in the list. We don't need to delete that one only to create another every time.
								keeper = true;
								sattrs[usedid] = "no"; 
							}
						} else {
							sattrs[usedid] = "yes";
						}
					}
					// At this point if keeper = true, we don't need to create a new row; if false, we do.
					// Or, if there are no entries, we need to create one, because there always needs to be at least one.
					if ( ! keeper || slist.length === 0 ) {
						var stringid = "repeating_strings_" + generateActuallyUniqueRowID();
						sattrs[`${stringid}_used`] = "no"; // Creates our a new String entry
					}
					log("Setting attributes for strings");
					log(sattrs);
					setAttrs(sattrs,{silent:true}); // We don't need to trigger a bunch of runs through this handler because we're setting attributes *with* this handler.
				});
			} else { // I suspect if there's no array, getAttrs doesn't bother to fire off its callback, which is a shame because I expected it to.
				log("list is empty, so we create");
				var stringid = "repeating_strings_" + generateActuallyUniqueRowID();
				sattrs[`${stringid}_used`] = "no"; // Creates our a new String entry
				log(sattrs);
				setAttrs(sattrs,{silent:true}); // We don't need to trigger a bunch of runs through this handler because we're setting attributes *with* this handler.
			}
		});
	});

	// Modifiers and Roll Button Adjustments

	var rwm = gTBK("roll with modifier");

	on("change:rollprompt-mods change:rollprompt-query change:modifier-tally", function() {
		log("We've got a change in roll prompt configuration");
		getAttrs(["rollprompt-mods","rollprompt-query","modifier-tally"], function(f) {
			log(f);
			var defaultconfig = "?{" + rwm + " +/-?|0}";
			var usemods = "1";
			if ( typeof f["rollprompt-mods"] === "undefined" || f["rollprompt-mods"] !== "1") {
				usemods = "0";
			}
			var doquery = "1";
			if ( typeof f["rollprompt-query"] === "undefined" || f["rollprompt-query"] !== "1") {
				doquery = "0";
			}
			var tally = "0";
			if ( typeof f["modifier-tally"] !== "undefined" ) {
				tally = f["modifier-tally"];
			}
			var attrs = {};
			log(`usemods ${usemods} doquery ${doquery} tally ${tally}`);
			if ( usemods === "1" ) {
				if ( doquery === "1" ) {
					// Use standard default config
					attrs["rollprompt"] = "?{" + rwm + "+/-?|"+tally+"}";
				} else {
					// We don't want to be bothered by it at all
					attrs["rollprompt"] = tally; // just add the tally
				}
			} else { // then usemods === 0; we don't tally, so this is simple action
				if ( doquery === "1" ) {
					// Use standard default config
					attrs["rollprompt"] = defaultconfig;
				} else {
					// We don't want to be bothered by it at all
					attrs["rollprompt"] = "";
				}
			}
			setAttrs(attrs);
		});
	});

	// Externalize stats data
	
	on("change:repeating_stats:rating", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-6); // strips off 'rating';
		var rid = rowprefix + "rating";
		var kid = rowprefix + "key";
		getAttrs([rid,kid], function(a) {
			var ratname = "stat_" + a[kid];
			var rats = {};
			rats[ratname] = a[rid];
			setAttrs(rats);
		});
	});

	// Externalize move selection data

	on("change:repeating_moves:taken", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-5); // strips off 'taken';
		var mid = rowprefix + "taken";
		var pid = rowprefix + "playbook";
		var nid = rowprefix + "name";
		getAttrs([mid,pid,nid], function(a) {
			var mats = {};
			var matname = "move-" + a[pid] + "-" + a[nid]; // e.g., move-beast-Ferocious
			var taken = "0";
			if ( a[mid] === "yes" ) { taken = "yes"; }
			mats[matname] = taken;
			setAttrs(mats);
		});
	});

	// Externalize conditions data
	
	on("change:repeating_conditions:marked", function(e) {
		var rowprefix = (e.sourceAttribute).slice(0,-6); // strips off 'marked';
		var mid = rowprefix + "marked";
		var pdid = rowprefix + "penalized";
		var pnid = rowprefix + "penalty";
		var nid = rowprefix + "name";
		getAttrs([mid,pdid,pnid,nid], function(a) {
			var cats = {};
			var catname = "condition-" + a[nid];
			var marked = "no";
			if ( a[mid] === "yes" ) { marked = "yes"; }
			cats[catname] = marked;
			var penalty = 0;
			var catpen = "condition-penalty-" + a[pdid];
			if ( marked === "yes" ) {
				penalty = Number(a[pnid]);
			}
			cats[catpen] = penalty;
			setAttrs(cats);
		});
	});
	
	// Externalize experience data
	
	on("change:xp1 change:xp2 change:xp3 change:xp4 change:xp5", function() {
		getAttrs(["xp1","xp2","xp3","xp4","xp5"], function(x) {
			var sum = 0;
			for(var i=1; i <= 5; i++) {
				if ( typeof x[`xp${i}`] !== "undefined" && x[`xp${i}`] == "1" ) { sum++; }
			}
			setAttrs({experience: sum});
		});
	});

</script>
